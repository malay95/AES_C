=Secure Coding

Secure coding is a practice of developing computer software to prevent from any future vulnarabilities or insecurity. Bugs, flaws and defects are the main cause of software vulnarabilities. These defects, flaws are occured due to some common software programming errors. We are going to enumerate where we have used secure coding complying the SERT document for secure coding. 

Before enumerating the code, there are many standards which we have followed through out our implementation. These rules or recommendations are: +
- DCL31-C - Declare identifiers before using them +
- DCL39-C - Avoid information leakage when passing a structure across trust boundaries +
- DCL40-C - Do not create incompatible declarations of the same object or function +
- ARR30 C - Do not form or use out of bounds pointers or array subscript +
- MSC30 C - Do not use rand() function for generating pseudo random generators +
- MSC37 C - Ensure that control never reaches the end of a non-void function +
- DCL07-C - Include the appropriate type information in function declarators +
- INT07-C - Use only explicitly signed or unsigned char type for numeric values +

Below are some of the secure coding rules and recommendation that we have used in our code. 

AES.c
[source,c]
----
#define getrandom(buf, size, flags) syscall(SYS_getrandom, buf, size, flags) 
----
MSC30 C - Do not use rand() function for generating pseudo random generators

'''


common.c
[source,C]
----
uint8_t c2 = a & 0xF; //second 4 bits of a
	uint8_t c1 = a >> 4;  //first 4 of a
	static const uint8_t s[16][16] = <1> 
 	{
    	{0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76},
    	{0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0},
	.
	.
	}
----
<1> EXP 40-C - Donot modify const objects

'''

common.c
[source,C]
----
uint8_t xtime(uint8_t value)
{
     uint8_t temp = value << 1; <1>
     if(GETBIT(value, 7) == 1){    
          temp ^= 0x1b;
     }
     return temp;
}

uint8_t finite_mul(uint8_t a, uint8_t b) {
     volatile uint8_t gf[OCTET];
     volatile int i;
     volatile uint8_t result = 0;

     gf[0] = a;
     for(i=1;i<OCTET;i++){
          gf[i] = xtime(gf[i-1]); <2>
     }

     for (i=0;i<OCTET;i++){
          if(GETBIT(b,i) == 1) {
               result ^= gf[i];
          }
     }

     return result;
}
----

<1> INT34 C - Do not shift an expression by a negative number of bits that exists in the operand
<2> EXP33 C - Donot read uninitialized memory. Here the function Xtime is called only after assigning any value to it.

'''
AES.c 
[source,c]
----
void arrayXor (uint8_t *a, uint8_t *b,uint8_t *out,int l){  <1>
	int i;
	for (i=0;i<l;i++){
		out[i]= a[i] ^ b[i];
	}
}
----

<1> ARR32 C - Ensure size arguments for variable length arrays are in valid range

'''

AES.c
[source,c]
----
int Cipher(block_t *in, block_t *out, key_t *key) {
     state_t state;		
     key_size_t key_size = key->key_size;
     block_t key_schedule;
     uint8_t *w;
     int Nb;
     int Nk;
     int Nr;
     int r;
	int c;
.
.
.
----

DCL04-C - Do not declare more than one variable per declaration
DCL19-C - Minimize the scope of variables and functions

'''

common.h 
[source,c]
----
typedef struct {
     uint8_t array[BLOCK_SIZE];
     int size;
} block_t;

typedef struct {
     uint8_t array[STATE_ROWS][NB_SIZE];
     int rows;
     int columns;
} state_t;
.
.
.
----

DCL05-C - Use typedefs of non-pointer types only

'''

AES.c 
[source,c]
----
state.array[r][c] = in->array[(r*STATE_ROWS)+c];
----

----
copySubArray(w, key_schedule.array,(r*Nb), (r+1)*Nb-1);
----

----
out->array[(r*STATE_ROWS)+c] = state.array[r][c];
----

EXP00-C - Use parentheses for precedence of operation

'''
ShiftRows.c
[source,c]
----
void shiftRows(state_t *state) {
     int r;
	int c;
     volatile uint8_t row[STATE_ROWS];

     for(r=1;r<STATE_ROWS;r++) {
          for(c=0;c<NB_SIZE;c++) {
               row[c] = state->array[r][(c+SHIFT(r,NB_SIZE) % NB_SIZE)];   <1>
          }
          for(c=0;c<NB_SIZE;c++) {
               state->array[r][c] = row[c]; 							<1>
          }
     }
}
----

EXP19-C - Use braces for the body of an if, for, or while statement 

'''

AES.c
[source,c]
----
void copySubArray(uint8_t *in, uint8_t *out, int from, int to){
.
----

ARR02-C - Explicitly specify array bounds, even if implicitly defined by an initializer
